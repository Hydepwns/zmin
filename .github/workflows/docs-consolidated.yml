name: Documentation Generation & Deployment

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**/*.zig'
      - 'docs/**'
      - 'content/**'
      - 'config.yaml'
      - 'static/**'
      - 'layouts/**'
      - 'assets/**'
      - 'go.mod'
      - 'go.sum'
      - '.github/workflows/docs-consolidated.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'src/**/*.zig'
      - 'docs/**'
      - 'content/**'
      - 'config.yaml'
      - 'static/**'
      - 'layouts/**'
      - 'assets/**'
      - 'go.mod'
      - 'go.sum'
      - '.github/workflows/docs-consolidated.yml'
  schedule:
    # Weekly documentation update at 3 AM UTC on Sundays
    - cron: '0 3 * * 0'
  workflow_dispatch:
    inputs:
      force_regenerate:
        description: 'Force regenerate all documentation'
        required: false
        default: false
        type: boolean
      deploy_only:
        description: 'Deploy existing documentation without regeneration'
        required: false
        default: false
        type: boolean

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: write
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

env:
  GENERATED_SPEC: docs/api-reference-generated.json
  GENERATED_HTML: docs/api-reference-generated.html

jobs:
  # Read versions inline instead of using reusable workflow
  versions:
    runs-on: ubuntu-latest
    outputs:
      zig-version: ${{ steps.versions.outputs.zig }}
      zmin-version: ${{ steps.versions.outputs.zmin }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github/versions.json

      - name: Read versions
        id: versions
        run: |
          echo "zig=$(jq -r '.zig' .github/versions.json)" >> $GITHUB_OUTPUT
          echo "zmin=$(jq -r '.zmin' .github/versions.json)" >> $GITHUB_OUTPUT

  # Generate API documentation
  generate-api-docs:
    name: Generate API Documentation
    needs: versions
    runs-on: ubuntu-latest
    if: |
      github.event.inputs.deploy_only != true

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Zig
        uses: goto-bus-stop/setup-zig@v2
        with:
          version: ${{ needs.versions.outputs.zig-version }}

      - name: Install swagger-cli
        run: |
          npm install -g @apidevtools/swagger-cli

      - name: Generate OpenAPI specification
        run: |
          echo "Generating OpenAPI specification..."

          # Create docs directory if it doesn't exist
          mkdir -p docs

          # Check if the generate-api-spec target exists
          if zig build --help | grep -q "generate-api-spec"; then
            # Generate the OpenAPI spec using Zig
            zig build generate-api-spec

            # Validate the generated spec
            if [ -f "api-reference.yaml" ]; then
              swagger-cli validate api-reference.yaml
              mv api-reference.yaml ${{ env.GENERATED_SPEC }}
              echo "✅ OpenAPI specification generated and validated"
            else
              echo "❌ Failed to generate OpenAPI specification"
              exit 1
            fi
          else
            echo "⚠️ generate-api-spec target not available, creating placeholder files"

            # Create placeholder files so the workflow doesn't fail
            echo '{"info": {"title": "zmin API", "version": "1.0.0"}, "paths": {}}' > ${{ env.GENERATED_SPEC }}
            echo '<html><head><title>zmin API Reference</title></head><body><h1>zmin API Reference</h1><p>API documentation will be generated when the generate-api-spec build target is implemented.</p></body></html>' > ${{ env.GENERATED_HTML }}

            echo "✅ Placeholder API documentation created"
          fi

      - name: Generate HTML documentation
        run: |
          echo "Generating HTML documentation..."

          # Check if the API spec file exists
          if [ -f "${{ env.GENERATED_SPEC }}" ]; then
            # Check if this is a placeholder file (contains empty paths)
            if grep -q '"paths": {}' "${{ env.GENERATED_SPEC }}"; then
              echo "⚠️ Placeholder API spec detected, HTML file already created in previous step"
            else
              # Use swagger-cli to generate HTML
              swagger-cli bundle ${{ env.GENERATED_SPEC }} --type html --outfile ${{ env.GENERATED_HTML }}

              if [ -f "${{ env.GENERATED_HTML }}" ]; then
                echo "✅ HTML documentation generated"
              else
                echo "❌ Failed to generate HTML documentation"
                exit 1
              fi
            fi
          else
            echo "⚠️ API spec file not found, skipping HTML generation"
          fi

      - name: Upload generated API docs as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: generated-api-docs
          path: |
            ${{ env.GENERATED_SPEC }}
            ${{ env.GENERATED_HTML }}
          retention-days: 1

  # Build Hugo site
  build-hugo:
    name: Build Hugo Site
    needs: [versions, generate-api-docs]
    runs-on: ubuntu-latest
    if: |
      github.event.inputs.deploy_only != true ||
      always()

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download generated API docs
        uses: actions/download-artifact@v4
        with:
          name: generated-api-docs
          path: docs/



      - name: Setup Hugo
        uses: peaceiris/actions-hugo@v2
        with:
          hugo-version: 'latest'
          extended: true

      - name: Build site
        run: |
          # Don't try to initialize modules if go.mod already exists
          if [ ! -f "go.mod" ]; then
            hugo mod init zmin-docs
          fi
          hugo mod get github.com/panr/hugo-theme-terminal
          hugo --minify

      - name: Upload Hugo site as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: hugo-site
          path: public/
          retention-days: 1

  # Deploy to GitHub Pages
  deploy:
    name: Deploy to GitHub Pages
    needs: [versions, build-hugo]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      pages: write
      id-token: write
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Hugo site
        uses: actions/download-artifact@v4
        with:
          name: hugo-site
          path: public/

      - name: Download generated API docs
        uses: actions/download-artifact@v4
        with:
          name: generated-api-docs
          path: docs/
        continue-on-error: true

      - name: Copy generated API docs to static directory
        run: |
          # Debug: List contents
          echo "Contents of docs/ directory:"
          ls -la docs/ || true

          echo "Contents of public/ directory:"
          ls -la public/ || true

          # Copy generated files if they exist
          if [ -f "${{ env.GENERATED_SPEC }}" ]; then
            cp "${{ env.GENERATED_SPEC }}" public/
            echo "✅ Copied ${{ env.GENERATED_SPEC }} to public/"
          else
            echo "⚠️ ${{ env.GENERATED_SPEC }} not found"
          fi

          if [ -f "${{ env.GENERATED_HTML }}" ]; then
            cp "${{ env.GENERATED_HTML }}" public/
            echo "✅ Copied ${{ env.GENERATED_HTML }} to public/"
          else
            echo "⚠️ ${{ env.GENERATED_HTML }} not found"
          fi

      - name: Setup Pages
        uses: actions/configure-pages@v4

      - name: Upload site
        uses: actions/upload-pages-artifact@v3
        with:
          path: public/

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
